28/08/2025 (MEMORY) cs50.ly/art
- pixel art
- RGB

- Hexadecimal(base-16): hexadecimal (details image file in this folder)
.convenient. (cause of 4 bits) (8 bits a byte - FF)
- 16 digits in alphabet 0 to F, 4 bits of zeroes and ones to represents 16 different values. (2 power 4 = 16)

- Memory
'&' (ampersand): ask the computer at what address is this variable
%p (a pointer in C) - format specifier tells printf to print the memory address of n in hexadecimal format.
&n - gives the address of the variable n, not its value.

pointers in C: a pointer is a variable that stores the memory address of another variable. takes 8 bytes rather than just 4, for storing more address and this way computers can have more memory. (points at the location of the memory we care, cause no one cares about the addresses)

'*' (asterisk): take an address and go to it.
int *p = &n; - I want p to be a pointer variable that stores an address
- when I only print p, it shows the address
- but when I print *p (without specifying a type), it shows who's address it's storing (just go there), meaning go to that address and show me what's inside of the computer's memory there.

- Strings: (reminder: string always contains a null character [\0] - end)
string s = "hi!" - here s is technically a pointer. that points for the beggining of a string, until found null = char *s (in standard C, string is just an array of characters)

- typedef int integer(name of the struct); give me a datatype of integer that's actually an int
- typedef uint8_t BYTE; an unsigned integer with 8 bits (datatype)
- typedef char *string; in cs50.h header file (teaches clang to think of the string as being synonimous with char *)

- pointer arithmetic: 
s[0] for printing the first character of a string
*s is doing the same thing
s[1] for printing the second character of a string
*(s + 1) is doing the same thing

- String Comparison:
actually comparing the addresses of the first character.
that's why we use strcmp to compare them char by char. using ASCIIbetical order.

29/08/2025
- Copying:
- malloc
- free
- NULL: it's just an address (zero), that can indicate when something has gone wrong, copy.c file in details
- NUL: meaning string ends here

- malloc and Valgrind:

- Valgrind: Valgrind is like a debugger for your memory. valgrind ./filename.c - only for memory related bug
- Memory leaks: you allocated memory with malloc but never freed it (free)
- Invalid reads/writes → you’re accessing memory you don’t own
- Using uninitialized memory → using variables before assigning them a value
- Double frees → trying to free memory twice.

- an array is just contiguous memory and malloc returns to me a bunch of contiguous memory (as an array)
- int *x = malloc(3 * sizeof(int)); -- Reserves enough memory for 3 integers, and x points to that memory

- garbage values:  leftover data (When you declare a variable like int x; but do not assign a value to it, x still contains whatever data was left there from previous programs or operations) is called a garbage value

- Pointers fun with blinky
int main(void)
{
    int *x;
    int *y;

    x = malloc(sizeof(int));
    *x = 42;

    y = x;
    *y = 13;
}
(overwriting the same memory)
(two pointers pointing to the same memory)

- scope:
- passing by value
(at the top of computer's memory block goes the machine code (0, 1), below that goes global variables, then heep -->  <-- at the bottom of this is stack)(one can overflow the other)

- when I use malloc, it comes from the heep memory(specifically)
- when I use functions with variables and arguments, I'm using stack memory

- stack: (when using the swap function)

- Pass by value → copies the value, original unchanged.
- Pass by reference (via pointers in C) → gives the function access to the original variable. (details in swap.c file)

- overflow:
Heap = manual, tied to malloc/free
Stack = automatic, tied to scope

- too much recursion can cause stack overflow
- heap overflow
- stack overflow
- buffer overflow

- scanf:
- scanf is not good for using in getting user's input as int or as string, cause of it's lack of error handling. (cs50 on the other hand has this ability)
- segmentation fault

- File I/O: (file input and output)
fopen → open file
fclose → close file
fprintf → write text
fscanf → read text
fwrite → write binary data
fread → read binary data
fseek → move inside file
(details in phonebook.c)

- BMP (bitmap file): essentially implements images (.bmp)
