26/08/2025
Algorithms:

- how to think algorithmically
- Linear Search
hashing, works on unsorted
- Binary Search
dividing in half until solved, only works if sorted.

- Pseudocode (important for problem solving): writing codes in plane English

- running time of Algorithm:
big O notation: how fast or slow the algorithm's gonna be
represents: upper bound

O(nÂ²) - quadratic time (nested loops, bad for big inputs)
O(n log n) - 
O(n) - linear
O(log n) - binary
O(1) - faster (const number of steps)

- Î© (Omega) notation:
represents lower bound. as few as these steps
Î©(1) - both linear and binary search

- Î˜ (theta) notation: when best and worst grow the same

- string.h

- strcmp(strings[i], s) == 0 - ASCIIbetical value:
0 â†’ if the two strings are equal

negative number â†’ if first string is less than second string (alphabet order)

positive number â†’ if first string is greater than second string

- data structures:
typedef struct:

typedef: invent the following datatype for me
at the end of curly brace is the name of the new datatype. more details on phonebook.c file

- sorting
unsorted ->    -> sorted


27/08/2025

selection sort:

selecting the smallest element again and again. if the list is already sorted, there's no pseudocode for selection sorting, it's gonna blindly do it's work.

for i from 0 to (n-1) - this loop is telling to do something n times
    find smallest number between numbers[i] and numbers[n-1] - this line is telling to do something n times as well.

    swap smallest number with number[i]
that's why running time is nÂ²
O(nÂ²), Î©(nÂ²)


bubble sort:

ompare one pair -> swap them -> then compare the next pair

repeat n times (repeat n-1 times - also correct, the last one endsd up being in place)
    for i from 0 to n-2 (this inner loop also repeating n-1 time)
         if numbers[i] and numbers[i+1] out of order
             swap now
    if no swaps
       quit

(n-1) - it's not for this one cause it'll be out of the list, left hand is [i] and right hand is [i+1] that's why n - 2

this also is not taking in account wether or not the list is already sorted.
running time is nÂ²
O(nÂ²), Î©(n)

ðŸ”¹ Selection Sort
No matter what the input looks like (sorted or unsorted), Selection Sort always searches through the whole list to find the smallest element.
That means the number of comparisons is always the same.

So:

Worst case (O) = O(nÂ²)
Best case (Î©) = Î©(nÂ²) âœ…

ðŸ‘‰ Selection sort never gets lucky â€” even if the list is already sorted.

ðŸ”¹ Bubble Sort
Bubble sort compares neighbors and swaps if needed.
If the list is already sorted, it can finish in just one pass (because no swaps happen).

So:

Worst case (O) = O(nÂ²) (lots of swaps if itâ€™s reversed)
Best case (Î©) = Î©(n) âœ…

ðŸ‘‰ Bubble sort can sometimes be faster than selection sort if the input is already sorted.

but both selection and bubble sorting are pretty slow.
- recursion: A function that calls itself to solve a problem. makes the steps shorter for faster problem solving.

- Merge sort:
pseudocode:
if only one number
	quit
else
	sort the left half
	sort the right half
	merge the sorted halves

running time for merge sort: log base 2 n
O(nlogn), Î©(nlogn), Î˜ (nlogn)

not as good as linear or binary search but way better than selection and bubble sort.

