04/09/2025
- SQL (Structured Query Language)
- flat file database (.csv (coma separated values), txt)
- Flat file = like Excel/CSV, simple but limited.
- SQL database = relational, powerful, scalable, secure.

- favoriotes.py:
- when we open file using 'with open' function, there's no need to close the file, it'll be closed automatically
- next(reader) the header row will be skipped (csv.reader used here)
- but when we use csv.DictReader, every row becomes a dictionary being the value and the key for that Dict is the header file
- counts = {} / counts = dict() [empty dict]
- sorted(counts) - by default sort by key
- when I make a dictionary then I can use all the functions that comes with dictionary in python
- from collection import Counter (here Counter has the counting capabilities build in)
- counts.most_common() also a dict function and it returns with pair of key-value

- counts.most_common(3) for top 3 result (by value)

- for fav, count in counts.most_common(): pair of fav count fav count

- read Counter() doc


- Relational Database:
- SQL (SQL follows this CRUD paradigms which means in a relational database you can only do 4 things)

CREATE, INSERT
READ (SELECT use it more)
UPDATE
DELETE, DROP
(these above commands only apply on filename.db type files)

- lite version of sql
- sqlite3 (sqlite3 FILE creates a binary file)
- .schema - shows you the structure (blueprint) of the database. In other words, it prints the SQL commands that were used to create the tables, indexes, and other objects in that database

- SELECT columns FROM tables
- SELECT * FROM favorites - Show me all rows and all columns from the table called favorites inside the database favorites.db
- * (star sign) means all columns
- ascii art used in this command

- AVG
- COUNT
- DISTINCT
- LOWER
- MAX
- MIN
- UPPER
(all of these functionality in sql)
- WHERE
- LIKE
- ORDER BY (default: ASC || DESC)
- LIMIT
- GROUP BY
- JOIN (like shows.db)

- adding data to new database
- INSERT INTO database_name (column_name, column_name) VALUES(values for those 2 columns selected)

- DELETE FROM database_name (this'll delete the full database) WHERE column_name NULL; (just for an example where in that column there is a NULL value I wanna delete the whole row)

- UPDATE table SET column = value WHERE condition; (Updating the database, saying which column to update and what values to enter as an updated data)

05/09/2025
- IMBb (Internet Movie Database)
- schema
- tsv (tab separated values, which the same thing when we look for tab character instead of comas(csv))

- one-to-one relationship data: each row in one table matches with only one row in another table

- data types:

- BLOB (binary large object)
- INTEGER
- NUMERIC
- REAL (real numbers aka float, decimal points in them)
- TEXT
- other keywords:
- NOT NULL (while designing a database I can specify that this column can't be NULL with it)
- UNIQUE (must be unique, avoid duplicate)

- Primary Key = unique ID in its own table
- Foreign Key = points to a primary key in another table

- querying
- nested querying
- for example:

SELECT * FROM shows WHERE id IN (SELECT show_id FROM ratings WHERE rating >= 6.0 LIMIT 10); - this's is gonna do the work inside the parenthesis first then do the outside. with this cmd I'm getting show name with show id that has the rating of 6 or over

- JOIN keyword: for joining two tables in database
- for example:
SELECT * FROM shows JOIN ratings ON shows.id = ratings.show_id WHERE rating >= 6.0 LIMIT 10;

- one-to-many relationship: (IMDb also supports)
- for example there is some movies or shows that has more than one genre.
SELECT * FROM shows JOIN genres ON shows.id = genres.show_id WHE
RE genre = 'Comedy' LIMIT 10;
SELECT title, year, genre FROM shows JOIN genres ON shows.id = genres.show_id WHERE genre = 'Comedy' LIMIT 10;

- when we join data with a one-to-many relationship we're gonna get temporary duplicates


- many-to-many relationship:
- middle (junction) table: bridge the two

- for example:
SELECT person_id FROM stars WHERE show_id = (SELECT id FROM shows
s WHERE title = 'The Office' AND year = 2005);

SELECT title FROM shows WHERE id IN (SELECT show_id FROM stars W
HERE person_id = (SELECT id FROM people WHERE name = 'Steve Carell'));

- IN allows multiple matches — so you get a list of names

SELECT title FROM shows, stars, people
   ...> WHERE shows.id = stars.show_id
   ...> AND stars.person_id = people.id
   ...> AND name = 'Steve Carell';

- indexes: a data structures that makes it faster to perform queries (like SELECT) 

- CREATE INDEX name ON table (column, ....); (on specific table on specific column)

- saves much much more times
- without creating index when we perform searching (as I did above in vs code) it does linear search underneath the hood (that takes more time)

- B-trees (when we create index): the sorter the tree is the more less time it'll take to give the output
- primary keys are automatically indexed, foreign keys aren't
- so, why not index every column and every table?
- when we create index we're trading lots of space to save some time

- python and SQL
- from cs50 import SQL
- sql is best for reading data from databases and python is best creating a user interface or a web app

- race conditions: when we have lots of data, and handling those data lots of server this happens. A race condition happens when two users/programs try to change the same data at the same time
- when server is racing to handle one user and other user's requests are happening at the same time
- BEGIN TRANSACTION
- COMMIT
- ROLLBACK
- Locking rows/tables temporarily → so only one transaction can edit them at a time
- Ensuring atomicity → either all changes succeed (COMMIT) or none (ROLLBACK)
- Keeping data consistent → no half-finished updates leak out

- SQL injection attack
